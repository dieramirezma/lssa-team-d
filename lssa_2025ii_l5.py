# -*- coding: utf-8 -*-
"""lssa_2025ii_l5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/172iT7235QrRrnfcW7tYFtCsjbqtisypP

**Arquitectura de Software a Gran Escala, 2025ii**</br>
Jeisson Andrés Vergara Vargas

# Laboratorio #5: Verificación Arquitectónica

## Descripción

En este laboratorio se explorará una parte de la arquitectura del Sistema Europeo de Gestión de Trenes (ERTMS) a través de una simulación utilizando el lenguaje de programación Python. Utilizando un modelo arquitectónico base, se han agregado funciones para soportar el patrón arquitectónico de balanceo de carga.

## Objetivo General

Desarrollar una comprensión profunda de la arquitectura de software a gran escala mediante el modelado, simulación y análisis de un sistema complejo como el ERTMS. Además, evidenciar cómo las tácticas arquitectónicas son útiles para soportar atributos de calidad como el rendimiento, la disponibilidad, etc.

## Objetivos Específicos

1. **Modelado**: Construir una representación abstracta de la arquitectura ERTMS.
2. **Instanciación**: Crear y configurar los componentes que conforman la arquitectura del sistema ERTMS.
3. **Balanceo de carga**: Utilizar técnicas de balanceo de carga para soportar el tráfico en momentos en que los componentes no tienen la capacidad completa.
4. **Resultados**: Analizar los datos obtenidos para identificar comportamientos exitosos y fallidos, así como los componentes críticos que afectan al sistema. Analizar los resultados en cada una de las técnicas de balanceo de carga aplicadas.

---

# Pasos de Ejecución

1. Modelado
2. Simulación con gráfico / simulación sin gráfico
3. Ejecutar alguna de las secciones de arquitectura
   - Arquitectura original
   - Balanceador de carga básico
   - Múltiple balanceador de carga
   - Round Robin (RR)
   - Round Robin ponderado
4. Ejecutar la simulación

# Modelado
"""

import threading
import time
import random
import networkx as nx
import matplotlib.pyplot as plt
from collections import defaultdict

# ================================
# 1. Modeling
# ================================

class Component:
    """
    Base class for all architecture components.
    """
    def __init__(self, name, component_type, capacity=100):
        self.name = name
        self.component_type = component_type
        self.capacity = capacity
        self.lock = threading.Lock()
        self.current_load = 0

    def process_transaction(self, transaction):
        """
        Processes a transaction. Returns True if the transaction is processed successfully,
        or False if the component's capacity is exceeded.
        """
        with self.lock:
            if self.current_load >= self.capacity:
                return False  # Over capacity failure
            self.current_load += 1
        # Simulate processing time
        processing_time = random.uniform(0.01, 0.05)
        time.sleep(processing_time)
        with self.lock:
            self.current_load -= 1
        return True

class PresentationTier(Component):
    """
    Class for components in Presentation Tier
    """
    def __init__(self, name, capacity=100):
        super().__init__(name, "Presentation Tier", capacity)

class LogicTier(Component):
    """
    Class for components in Logic Tier
    """
    def __init__(self, name, capacity=100):
        super().__init__(name, "Logic Tier", capacity)

class DataTier(Component):
    """
    Class for components in Data Tier
    """
    def __init__(self, name, capacity=100):
        super().__init__(name, "Data Tier", capacity)

class CyberPhysicalTier(Component):
    """
    Class for components in CyberPhysical Tier
    """
    def __init__(self, name, capacity=1000):
        super().__init__(name, "CyberPhysical Tier", capacity)

class Transaction:
    """
    Represents a transaction in the system.
    """
    def __init__(self, user, transaction_type, city=None):
        self.user = user  # User identifier (e.g., "user_ma_1")
        self.transaction_type = transaction_type  # "purchase" or "validation"
        self.city = city  # Only for validation transactions
        self.components_involved = []
        self.status = None  # "Success" or "Failed"

def represent_graph(graph, components):
    """
    Represents the architecture as a graph.
    """
    plt.figure(figsize=(12, 8))
    pos = nx.spring_layout(graph, k=0.5, iterations=50)

    # Assign colors based on component type
    color_map = {
        'Presentation Tier': 'lightblue',
        'Logic Tier': 'lightgreen',
        'Data Tier': 'orange',
        'CyberPhysical Tier': 'red'
    }
    node_colors = [color_map[components[node].component_type] for node in graph.nodes()]

    nx.draw(
        graph,
        pos,
        with_labels=True,
        node_color=node_colors,
        node_size=5000,
        font_size=7,
        font_weight='bold',
        arrows=True
    )
    plt.title("ERTMS Architecture Represented as a Graph")
    plt.show()

def visualize_metrics(metrics):
    """
    Visualizes the collected metrics using bar charts.
    """
    total = len(metrics)
    success = sum(1 for tx in metrics if tx.status == 'Success')
    failed = sum(1 for tx in metrics if tx.status == 'Failed')

    labels = ['Successful', 'Failed']
    counts = [success, failed]
    colors = ['green', 'red']

    plt.figure(figsize=(6, 6))
    plt.bar(labels, counts, color=colors)
    plt.title('Successful vs Failed Transactions')
    plt.xlabel('Status')
    plt.ylabel('Count')
    plt.show()

    type_metrics = defaultdict(lambda: {'Success': 0, 'Failed': 0})
    for tx in metrics:
        type_metrics[tx.transaction_type][tx.status] += 1

    types = list(type_metrics.keys())
    success_counts = [type_metrics[t]['Success'] for t in types]
    failed_counts = [type_metrics[t]['Failed'] for t in types]

    x = range(len(types))

    plt.figure(figsize=(12, 8))
    plt.bar(x, success_counts, width=0.4, label='Successful', color='green')
    plt.bar([p + 0.4 for p in x], failed_counts, width=0.4, label='Failed', color='red')
    plt.xlabel('Transaction Type')
    plt.ylabel('Count')
    plt.title('Transactions by Type')
    plt.xticks([p + 0.2 for p in x], [t.capitalize() for t in types], rotation=45)
    plt.legend()
    plt.tight_layout()
    plt.show()

def report_metrics(metrics):
    """
    Displays the metrics collected during the simulation.
    """
    total = len(metrics)
    success = sum(1 for tx in metrics if tx.status == 'Success')
    failed = sum(1 for tx in metrics if tx.status == 'Failed')
    print(f"\n=== Simulation Results ===")
    print(f"Total Transactions: {total}")
    print(f"Successful Transactions: {success}")
    print(f"Failed Transactions: {failed}\n")

    type_metrics = defaultdict(lambda: {'Success': 0, 'Failed': 0})
    for tx in metrics:
        type_metrics[tx.transaction_type][tx.status] += 1

    print("Summary by Transaction Type:")
    for t_type, counts in type_metrics.items():
        print(f"  {t_type.capitalize()}: {counts['Success']} successful, {counts['Failed']} failed")

    component_metrics = defaultdict(lambda: {'Processed': 0, 'Failed': 0})
    for tx in metrics:
        for comp in tx.components_involved:
            component_metrics[comp]['Processed'] += 1
        if tx.status == 'Failed':
            for comp in tx.components_involved:
                component_metrics[comp]['Failed'] += 1

    print("\nSummary by Component:")
    for comp, counts in component_metrics.items():
        print(f"  {comp}: Processed {counts['Processed']}, Failed {counts['Failed']}")

    print("\nDetails of Failed Transactions:")
    for tx in metrics:
       # if tx.status == '88d': # <--------------------------------------------------------------------------------------------------------------------------- logger
            if tx.transaction_type == 'purchase':
                user = tx.user
            else:
                user = f"{tx.user} in {tx.city}"
            #print(f"User: {user}, Type: {tx.transaction_type}, Components: {tx.components_involved}, Status: {tx.status}")

def run_simulation(components, metrics, purchase_count=1000, validation_count=1000):
    """
    Runs the simulation of concurrent transactions.
    """
    cities = [
        "Madrid", "Barcelona", "Valencia", "Seville",
        "Paris", "Lyon", "Marseille", "Nice", "Toulouse",
        "Rome", "Milan", "Venice", "Florence",
        "Berlin", "Munich", "Hamburg", "Frankfurt",
        "London", "Geneva", "Zurich", "Bruxeles", "Amsterdam"
    ]

    threads = []
    for i in range(1, purchase_count + 1):
        user = f"user_ma_{i}"
        transaction = Transaction(user, 'purchase')
        thread = threading.Thread(target=simulate_transaction, args=(transaction, components, metrics))
        threads.append(thread)
        thread.start()

    for i in range(1, validation_count + 1):
        user = f"station_da_{i}"
        city = random.choice(cities)
        transaction = Transaction(user, 'validation', city)
        thread = threading.Thread(target=simulate_transaction, args=(transaction, components, metrics))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

"""# Simulación con gráfico

En la fase de Graficación, se generan representaciones visuales de la arquitectura del sistema y de los resultados obtenidos durante la simulación. La visualización es una herramienta poderosa para analizar y comunicar la estructura del sistema, así como para interpretar los datos de rendimiento y detectar posibles cuellos de botella o puntos de fallo.
"""

def run_ertms_simulation():
    """
    Configura la arquitectura del sistema ERTMS, ejecuta la simulación de transacciones,
    reporta los resultados, visualiza las métricas y representa la arquitectura antes y después
    de inducir una falla.
    """
    # Setup architecture
    components, graph = setup_architecture()

    # Represent the initial architecture
    print("=== Initial Architecture Representation ===")
    represent_graph(graph, components)

    # Metrics collection
    metrics = []

    # Simulate transactions with initial capacity
    print("\n=== Simulating Transactions with Initial Architecture ===")
    run_simulation(components, metrics)
    report_metrics(metrics)
    visualize_metrics(metrics)

    # Induce a failure in the architecture
    induce_failure(components)

    # Clear previous metrics
    metrics.clear()

    # Simulate transactions after inducing failure
    print("\n=== Simulating Transactions with Failure Scenario ===")
    run_simulation(components, metrics)
    report_metrics(metrics)
    visualize_metrics(metrics)

    # Represent the architecture after failure
    print("\n=== Architecture Representation After Failure ===")
    represent_graph(graph, components)

"""# Simulación sin gráfico"""

def run_ertms_simulation():
    """
    Configura la arquitectura del sistema ERTMS, ejecuta la simulación de transacciones,
    reporta los resultados, visualiza las métricas y representa la arquitectura antes y después
    de inducir una falla.
    """
    # Setup architecture
    components, graph = setup_architecture()


    # Metrics collection
    metrics = []

    # Simulate transactions with initial capacity
    print("\n=== Simulating Transactions with Initial Architecture ===")
    run_simulation(components, metrics)
    report_metrics(metrics)

    # Induce a failure in the architecture
    induce_failure(components)

    # Clear previous metrics
    metrics.clear()

    # Simulate transactions after inducing failure
    print("\n=== Simulating Transactions with Failure Scenario ===")
    run_simulation(components, metrics)
    report_metrics(metrics)

"""# Arquitectura original

En esta sección de código se encuentra el modelado de la arquitectura de ERTMS básica, sin balanceo de carga.
"""

def setup_architecture():
    """
    Sets up the system architecture by instantiating components and defining their connections.
    """
    components = {}
    graph = nx.DiGraph()

    # Presentation Tier
    components['ertms_user_ma'] = PresentationTier('ertms_user_ma', capacity=200)
    components['ertms_station_da'] = PresentationTier('ertms_station_da', capacity=200)

    # Logic Tier
    components['ertms_ag'] = LogicTier('ertms_ag', capacity=500)
    components['ertms_purchase_ms'] = LogicTier('ertms_purchase_ms', capacity=300)
    components['ertms_validation_ms'] = LogicTier('ertms_validation_ms', capacity=300)

    # Data Tier
    components['ertms_purchase_db'] = DataTier('ertms_purchase_db', capacity=300)
    components['ertms_validation_db'] = DataTier('ertms_validation_db', capacity=300)

    # Physical Tier
    components['ertms_sensor'] = CyberPhysicalTier('ertms_sensor')
    components['ertms_train'] = CyberPhysicalTier('ertms_train')

    # Define connections between components
    graph.add_edge('ertms_user_ma', 'ertms_ag')
    graph.add_edge('ertms_station_da', 'ertms_ag')
    graph.add_edge('ertms_ag', 'ertms_purchase_ms')
    graph.add_edge('ertms_ag', 'ertms_validation_ms')
    graph.add_edge('ertms_purchase_ms', 'ertms_purchase_db')
    graph.add_edge('ertms_validation_ms', 'ertms_validation_db')
    graph.add_edge('ertms_validation_ms', 'ertms_sensor')
    graph.add_edge('ertms_validation_ms', 'ertms_train')

    return components, graph



def simulate_transaction(transaction, components, metrics):
    """
    Simulates the processing of a transaction through the involved components.
    """
    if transaction.transaction_type == 'purchase':
        components_sequence = ['ertms_user_ma', 'ertms_ag', 'ertms_purchase_ms', 'ertms_purchase_db']
    elif transaction.transaction_type == 'validation':
        components_sequence = ['ertms_station_da', 'ertms_ag', 'ertms_validation_ms', 'ertms_validation_db']
        components_sequence.extend(['ertms_sensor', 'ertms_train'])
    else:
        components_sequence = []

    transaction.components_involved = components_sequence
    success = True
    for comp_name in components_sequence:
        component = components.get(comp_name)
        if component:
            if not component.process_transaction(transaction):
                success = False
                transaction.status = 'Failed'
                break
        else:
            success = False
            transaction.status = 'Failed'
            break
    if success:
        transaction.status = 'Success'
    metrics.append(transaction)



def induce_failure(components):
    """
    Induces a failure in the architecture by reducing the capacity of a critical component.
    """
    critical_component = components.get('ertms_purchase_ms')
    if critical_component:
        critical_component.capacity = 50
        print("\n[Failure Scenario] Capacity of 'ertms_purchase_ms' reduced to 50.")

"""# Balanceador de carga básico

Distribuye la carga de manera aleatoria entre los servidores disponibles. Aunque es simple, puede ser eficiente en ciertos escenarios donde no hay una diferencia significativa en la carga de los servidores.
"""

def setup_architecture():
    """
    Sets up the system architecture by instantiating components and defining their connections.
    """
    components = {}
    graph = nx.DiGraph()

    # Presentation Tier
    components['ertms_user_ma'] = PresentationTier('ertms_user_ma', capacity=200)
    components['ertms_station_da'] = PresentationTier('ertms_station_da', capacity=200)

    # Logic Tier
    components['ertms_ag'] = LogicTier('ertms_ag', capacity=500)

    components['ertms_purchase_lb'] = LogicTier('ertms_purchase_lb', capacity=10000) # ----------------> New LoadBalancer

    components['ertms_purchase_ms_1'] = LogicTier('ertms_purchase_ms_1', capacity=300) # ----------------> New purchase_ms_1
    components['ertms_purchase_ms_2'] = LogicTier('ertms_purchase_ms_2', capacity=800) # ----------------> New purchase_ms_2

    components['ertms_validation_ms'] = LogicTier('ertms_validation_ms', capacity=300)

    # Data Tier
    components['ertms_purchase_db'] = DataTier('ertms_purchase_db', capacity=300)
    components['ertms_validation_db'] = DataTier('ertms_validation_db', capacity=300)

    # Physical Tier
    components['ertms_sensor'] = CyberPhysicalTier('ertms_sensor')
    components['ertms_train'] = CyberPhysicalTier('ertms_train')

    # Define connections between components
    graph.add_edge('ertms_user_ma', 'ertms_ag')
    graph.add_edge('ertms_station_da', 'ertms_ag')

    graph.add_edge('ertms_ag', 'ertms_purchase_lb')                             # ------------------> Change in flow

    graph.add_edge('ertms_ag', 'ertms_validation_ms')

    graph.add_edge('ertms_purchase_lb', 'ertms_purchase_ms_1')                  # ------------------> Change in flow
    graph.add_edge('ertms_purchase_lb', 'ertms_purchase_ms_2')                  # ------------------> Change in flow

    graph.add_edge('ertms_purchase_ms_1', 'ertms_purchase_db')                  # ------------------> Change in flow
    graph.add_edge('ertms_purchase_ms_2', 'ertms_purchase_db')                  # ------------------> Change in flow
    graph.add_edge('ertms_validation_ms', 'ertms_validation_db')
    graph.add_edge('ertms_validation_ms', 'ertms_sensor')
    graph.add_edge('ertms_validation_ms', 'ertms_train')

    return components, graph


def simulate_transaction(transaction, components, metrics):
    """
    Simulates the processing of a transaction through the involved components.
    """
    if transaction.transaction_type == 'purchase':
        components_sequence = ['ertms_user_ma', 'ertms_ag', 'ertms_purchase_lb',  random.choice(['ertms_purchase_ms_1', 'ertms_purchase_ms_2']), 'ertms_purchase_db']
    elif transaction.transaction_type == 'validation':
        components_sequence = ['ertms_station_da', 'ertms_ag', 'ertms_validation_ms', 'ertms_validation_db']
        components_sequence.extend(['ertms_sensor', 'ertms_train'])
    else:
        components_sequence = []

    transaction.components_involved = components_sequence
    success = True
    for comp_name in components_sequence:
        component = components.get(comp_name)
        if component:
            if not component.process_transaction(transaction):
                success = False
                transaction.status = 'Failed'
                break
        else:
            success = False
            transaction.status = 'Failed'
            break
    if success:
        transaction.status = 'Success'
    metrics.append(transaction)


def induce_failure(components):
    """
    Induces a failure in the architecture by reducing the capacity of a critical component.
    """
    critical_component = components.get('ertms_purchase_ms_1')
    if critical_component:
        critical_component.capacity = 50
        print("\n[Failure Scenario] Capacity of 'ertms_purchase_ms_1' reduced to 50.")

"""# Balanceador de carga múltiple

Distribuye la carga de manera aleatoria entre los servidores disponibles. Aunque es simple, puede ser eficiente en ciertos escenarios donde no hay una diferencia significativa en la carga de los servidores.
"""

def setup_architecture():
    """
    Sets up the system architecture by instantiating components and defining their connections.
    """
    components = {}
    graph = nx.DiGraph()

    # Presentation Tier
    components['ertms_user_ma'] = PresentationTier('ertms_user_ma', capacity=200)
    components['ertms_station_da'] = PresentationTier('ertms_station_da', capacity=200)

    # Logic Tier

    components['ertms_ag_lb'] = LogicTier('ertms_ag_lb', capacity=500)                  # ----------------> New LoadBalancer
    components['ertms_purchase_lb'] = LogicTier('ertms_purchase_lb', capacity=500)      # ----------------> New LoadBalancer
    components['ertms_validation_lb'] = LogicTier('ertms_validation_lb', capacity=500)  # ----------------> New LoadBalancer


    components['ertms_ag_1'] = LogicTier('ertms_ag_1', capacity=500)                   # ----------------> New ag_1
    components['ertms_ag_2'] = LogicTier('ertms_ag_2', capacity=500)                   # ----------------> New ag_2

    components['ertms_purchase_ms_1'] = LogicTier('ertms_purchase_ms_1', capacity=300) # ----------------> New purchase_ms_1
    components['ertms_purchase_ms_2'] = LogicTier('ertms_purchase_ms_2', capacity=300) # ----------------> New purchase_ms_2

    components['ertms_validation_ms_1'] = LogicTier('ertms_validation_ms_1', capacity=300) # ----------------> New
    components['ertms_validation_ms_2'] = LogicTier('ertms_validation_ms_2', capacity=300) # ----------------> New

    # Data Tier
    components['ertms_purchase_db'] = DataTier('ertms_purchase_db', capacity=300)
    components['ertms_validation_db'] = DataTier('ertms_validation_db', capacity=300)

    # Physical Tier
    components['ertms_sensor'] = CyberPhysicalTier('ertms_sensor')
    components['ertms_train'] = CyberPhysicalTier('ertms_train')

    # Define connections between components
    graph.add_edge('ertms_user_ma', 'ertms_ag_lb')                                  # ------------------> Change in flow
    graph.add_edge('ertms_station_da', 'ertms_ag_lb')                               # ------------------> Change in flow

    graph.add_edge('ertms_ag_lb', 'ertms_ag_1')                                     # ------------------> Change in flow
    graph.add_edge('ertms_ag_lb', 'ertms_ag_2')                                     # ------------------> Change in flow

    graph.add_edge('ertms_ag_lb', 'ertms_purchase_lb')                              # ------------------> Change in flow
    graph.add_edge('ertms_ag_lb', 'ertms_validation_lb')                            # ------------------> Change in flow

    graph.add_edge('ertms_purchase_lb', 'ertms_purchase_ms_1')                      # ------------------> Change in flow
    graph.add_edge('ertms_purchase_lb', 'ertms_purchase_ms_2')                      # ------------------> Change in flow


    graph.add_edge('ertms_validation_lb', 'ertms_validation_ms_1')                  # ------------------> Change in flow
    graph.add_edge('ertms_validation_lb', 'ertms_validation_ms_2')                  # ------------------> Change in flow

    graph.add_edge('ertms_purchase_ms_1', 'ertms_purchase_db')                      # ------------------> Change in flow
    graph.add_edge('ertms_purchase_ms_2', 'ertms_purchase_db')                      # ------------------> Change in flow
    graph.add_edge('ertms_validation_ms_1', 'ertms_validation_db')                  # ------------------> Change in flow
    graph.add_edge('ertms_validation_ms_2', 'ertms_validation_db')                  # ------------------> Change in flow

    graph.add_edge('ertms_validation_ms_1', 'ertms_sensor')
    graph.add_edge('ertms_validation_ms_1', 'ertms_train')

    graph.add_edge('ertms_validation_ms_2', 'ertms_sensor')
    graph.add_edge('ertms_validation_ms_2', 'ertms_train')

    return components, graph


def simulate_transaction(transaction, components, metrics):
    """
    Simulates the processing of a transaction through the involved components.
    """
    if transaction.transaction_type == 'purchase':
        components_sequence = ['ertms_user_ma', 'ertms_ag_lb' ,random.choice(['ertms_ag_1', 'ertms_ag_2']), 'ertms_purchase_lb', random.choice(['ertms_purchase_ms_1', 'ertms_purchase_ms_2']), 'ertms_purchase_db']
    elif transaction.transaction_type == 'validation':
        components_sequence = ['ertms_station_da', 'ertms_ag_lb',  random.choice(['ertms_ag_1', 'ertms_ag_2']), random.choice(['ertms_validation_ms_1', 'ertms_validation_ms_2']), 'ertms_validation_db']
        components_sequence.extend(['ertms_sensor', 'ertms_train'])
    else:
        components_sequence = []

    transaction.components_involved = components_sequence
    success = True
    for comp_name in components_sequence:
        component = components.get(comp_name)
        if component:
            if not component.process_transaction(transaction):
                success = False
                transaction.status = 'Failed'
                break
        else:
            success = False
            transaction.status = 'Failed'
            break
    if success:
        transaction.status = 'Success'
    metrics.append(transaction)


def induce_failure(components):
    """
    Induces a failure in the architecture by reducing the capacity of a critical component.
    """
    critical_component = components.get('ertms_purchase_ms_1')
    if critical_component:
        critical_component.capacity = 50
        print("\n[Failure Scenario] Capacity of 'ertms_purchase_ms_1' reduced to 50.")

"""# Round Robin

Este método distribuye las solicitudes de manera uniforme entre todos los servidores disponibles en forma de ronda. Cada vez que llega una nueva solicitud, el balanceador de carga la envía al siguiente servidor en la lista. Una vez que se llega al final de la lista, se comienza de nuevo desde el primer servidor.
"""

def raund_robin_lb(names):
    global index  # Reference to the global variable
    if not names:
        return None  # Returns None if the list is empty

    name = names[index]  # Gets the current name
    index = (index + 1) % len(names)  # Updates the index cyclically
    return name

def setup_architecture():
    """
    Sets up the system architecture by instantiating components and defining their connections.
    """
    components = {}
    graph = nx.DiGraph()

    # Presentation Tier
    components['ertms_user_ma'] = PresentationTier('ertms_user_ma', capacity=200)
    components['ertms_station_da'] = PresentationTier('ertms_station_da', capacity=200)

    # Logic Tier
    components['ertms_ag'] = LogicTier('ertms_ag', capacity=500)

    components['ertms_purchase_lb'] = LogicTier('ertms_purchase_lb', capacity=500) # ----------------> New LoadBalancer

    components['ertms_purchase_ms_1'] = LogicTier('ertms_purchase_ms_1', capacity=300) # ----------------> New purchase_ms_1
    components['ertms_purchase_ms_2'] = LogicTier('ertms_purchase_ms_2', capacity=800) # ----------------> New purchase_ms_2

    components['ertms_validation_ms'] = LogicTier('ertms_validation_ms', capacity=300)

    # Data Tier
    components['ertms_purchase_db'] = DataTier('ertms_purchase_db', capacity=300)
    components['ertms_validation_db'] = DataTier('ertms_validation_db', capacity=300)

    # Physical Tier
    components['ertms_sensor'] = CyberPhysicalTier('ertms_sensor')
    components['ertms_train'] = CyberPhysicalTier('ertms_train')

    # Define connections between components
    graph.add_edge('ertms_user_ma', 'ertms_ag')
    graph.add_edge('ertms_station_da', 'ertms_ag')

    graph.add_edge('ertms_ag', 'ertms_purchase_lb')                             # ------------------> Change in flow

    graph.add_edge('ertms_ag', 'ertms_validation_ms')
    graph.add_edge('ertms_purchase_lb', 'ertms_purchase_ms_1')                  # ------------------> Change in flow
    graph.add_edge('ertms_purchase_lb', 'ertms_purchase_ms_2')                  # ------------------> Change in flow

    graph.add_edge('ertms_purchase_ms_1', 'ertms_purchase_db')
    graph.add_edge('ertms_purchase_ms_2', 'ertms_purchase_db')

    graph.add_edge('ertms_validation_ms', 'ertms_validation_db')
    graph.add_edge('ertms_validation_ms', 'ertms_sensor')
    graph.add_edge('ertms_validation_ms', 'ertms_train')

    return components, graph


def simulate_transaction(transaction, components, metrics):
    """
    Simulates the processing of a transaction through the involved components.
    """
    if transaction.transaction_type == 'purchase':
        components_sequence = ['ertms_user_ma', 'ertms_ag', 'ertms_purchase_lb',  raund_robin_lb(["ertms_purchase_ms_1", "ertms_purchase_ms_2"]), 'ertms_purchase_db']
    elif transaction.transaction_type == 'validation':
        components_sequence = ['ertms_station_da', 'ertms_ag', 'ertms_validation_ms', 'ertms_validation_db']
        components_sequence.extend(['ertms_sensor', 'ertms_train'])
    else:
        components_sequence = []

    transaction.components_involved = components_sequence
    success = True
    for comp_name in components_sequence:
        component = components.get(comp_name)
        if component:
            if not component.process_transaction(transaction):
                success = False
                transaction.status = 'Failed'
                break
        else:
            success = False
            transaction.status = 'Failed'
            break
    if success:
        transaction.status = 'Success'
    metrics.append(transaction)


def induce_failure(components):
    """
    Induces a failure in the architecture by reducing the capacity of a critical component.
    """
    critical_component = components.get('ertms_purchase_ms_1')
    if critical_component:
        critical_component.capacity = 50
        print("\n[Failure Scenario] Capacity of 'ertms_purchase_ms_1' reduced to 50.")

"""# Weighted Round Robing

Similar al Round Robin, pero asigna "pesos" a los servidores. Aunque todos los servidores reciben solicitudes, aquellos con un peso mayor recibirán más solicitudes que los que tienen un peso menor. Esto permite manejar servidores con diferentes capacidades de rendimiento.
"""

def weighted_round_robin_lb(names, weights):
    global index, current_weight, max_weight

    # Check if the lists are empty
    if not names or not weights or len(names) != len(weights):
        return None

    # Set the maximum weight if not already done
    if max_weight == 0:
        max_weight = max(weights)

    while True:
        # Updates the index cyclically
        index = (index + 1) % len(names)

        if index == 0:
            # Increase current weight after completing a lap
            current_weight = (current_weight + 1) % (max_weight + 1)

        # If the current weight 0 is reached, continue to the next
        if current_weight == 0:
            continue

        # Check if the weight of the current name is greater than or equal to the current weight
        if weights[index] >= current_weight:
            return names[index]

def setup_architecture():
    """
    Sets up the system architecture by instantiating components and defining their connections.
    """
    components = {}
    graph = nx.DiGraph()

    # Presentation Tier
    components['ertms_user_ma'] = PresentationTier('ertms_user_ma', capacity=200)
    components['ertms_station_da'] = PresentationTier('ertms_station_da', capacity=200)

    # Logic Tier
    components['ertms_ag'] = LogicTier('ertms_ag', capacity=500)

    components['ertms_purchase_lb'] = LogicTier('ertms_purchase_lb', capacity=500) # ----------------> New LoadBalancer

    components['ertms_purchase_ms_1'] = LogicTier('ertms_purchase_ms_1', capacity=300) # ----------------> New purchase_ms_1
    components['ertms_purchase_ms_2'] = LogicTier('ertms_purchase_ms_2', capacity=800) # ----------------> New purchase_ms_2

    components['ertms_validation_ms'] = LogicTier('ertms_validation_ms', capacity=300)

    # Data Tier
    components['ertms_purchase_db'] = DataTier('ertms_purchase_db', capacity=300)
    components['ertms_validation_db'] = DataTier('ertms_validation_db', capacity=300)

    # Physical Tier
    components['ertms_sensor'] = CyberPhysicalTier('ertms_sensor')
    components['ertms_train'] = CyberPhysicalTier('ertms_train')

    # Define connections between components
    graph.add_edge('ertms_user_ma', 'ertms_ag')
    graph.add_edge('ertms_station_da', 'ertms_ag')

    graph.add_edge('ertms_ag', 'ertms_purchase_lb')                             # ------------------> Change in flow

    graph.add_edge('ertms_ag', 'ertms_validation_ms')
    graph.add_edge('ertms_purchase_lb', 'ertms_purchase_ms_1')                  # ------------------> Change in flow
    graph.add_edge('ertms_purchase_lb', 'ertms_purchase_ms_2')                  # ------------------> Change in flow


    graph.add_edge('ertms_purchase_ms_1', 'ertms_purchase_db')                  # ------------------> Change in flow
    graph.add_edge('ertms_purchase_ms_2', 'ertms_purchase_db')                  # ------------------> Change in flow

    graph.add_edge('ertms_validation_ms', 'ertms_validation_db')
    graph.add_edge('ertms_validation_ms', 'ertms_sensor')
    graph.add_edge('ertms_validation_ms', 'ertms_train')

    return components, graph


def simulate_transaction(transaction, components, metrics):
    """
    Simulates the processing of a transaction through the involved components.
    """
    names = ['ertms_purchase_ms_1', 'ertms_purchase_ms_2']
    weights = [1, 4]  # 'A' has greater weight, 'B' has less

    if transaction.transaction_type == 'purchase':
        components_sequence = ['ertms_user_ma', 'ertms_ag', 'ertms_purchase_lb',  weighted_round_robin_lb(names, weights), 'ertms_purchase_db']
    elif transaction.transaction_type == 'validation':
        components_sequence = ['ertms_station_da', 'ertms_ag', 'ertms_validation_ms', 'ertms_validation_db']
        components_sequence.extend(['ertms_sensor', 'ertms_train'])
    else:
        components_sequence = []

    transaction.components_involved = components_sequence
    success = True
    for comp_name in components_sequence:
        component = components.get(comp_name)
        if component:
            if not component.process_transaction(transaction):
                success = False
                transaction.status = 'Failed'
                break
        else:
            success = False
            transaction.status = 'Failed'
            break
    if success:
        transaction.status = 'Success'
    metrics.append(transaction)


def induce_failure(components):
    """
    Induces a failure in the architecture by reducing the capacity of a critical component.
    """
    critical_component = components.get('ertms_purchase_ms_1')
    if critical_component:
        critical_component.capacity = 50
        print("\n[Failure Scenario] Capacity of 'ertms_purchase_ms_1' reduced to 50.")

"""# Ejecutar simulación"""

index = 0
current_weight = 0
max_weight = 0
# Para ejecutar la función, simplemente llámala:
run_ertms_simulation()